*** a/src/sniper_bot.rs
--- b/src/sniper_bot.rs
@@
 use crate::executor::Executor;
+use crate::liquidity_guard::{load_thresholds_from_env, evaluate_guard};
+use crate::metrics_store::MetricsStore;

 pub struct SniperBot {
     executor: Executor,
+    metrics: MetricsStore,
 }

 impl SniperBot {
     pub fn new(executor: Executor) -> Self {
-        Self { executor }
+        Self {
+            executor,
+            metrics: MetricsStore::new(),
+        }
     }

     /// Call this whenever a leader wallet buys `mint`, and we want to mirror.
     pub async fn mirror_leader_buy(
         &mut self,
         mint: &str,
         requested_size_usd: f64,
     ) -> anyhow::Result<()> {
-        // OLD: immediately build route and fire (or simulate)
-        // NEW: gate on liquidity / mcap / volatility
-
-        // 1) Fetch metrics for this mint
-        let tm = match self.metrics.get(mint) {
-            Some(x) => x.clone(),
-            None => {
-                tracing::warn!(%mint, "no_metrics -> skip");
-                return Ok(());
-            }
-        };
-
-        // 2) Load thresholds from env
-        let th = load_thresholds_from_env();
-
-        // 3) Evaluate guard
-        let now = chrono::Utc::now();
-        let decision = evaluate_guard(mint, requested_size_usd, &tm, &th, now);
-
-        // 4) Log decision in structured way
-        tracing::info!(target="decision",
-            mint=%mint,
-            allowed=%decision.allowed,
-            reason=%decision.reason,
-            requested_size_usd=%decision.requested_size_usd,
-            vol_5m_usd=%decision.vol_5m_usd,
-            vol_15m_usd=%decision.vol_15m_usd,
-            liq_usd=?decision.liq_usd,
-            marketcap_usd=?decision.marketcap_usd,
-            amihud_5m=?decision.amihud_5m,
-            range_eff_5m=?decision.range_eff_5m,
-            "pre-trade guard decision"
-        );
-
-        if !decision.allowed {
-            tracing::warn!(%mint, reason=%decision.reason, "trade_blocked");
-            return Ok(());
-        }
-
-        // 5) continue with existing swap path build + simulate / send
-        self.executor.execute_swap(mint, requested_size_usd).await?;
-
-        Ok(())
+        // 1) Fetch metrics for this mint
+        let tm = match self.metrics.get(mint) {
+            Some(x) => x.clone(),
+            None => {
+                tracing::warn!(%mint, "no_metrics -> skip");
+                return Ok(());
+            }
+        };
+
+        // 2) Load thresholds from env
+        let th = load_thresholds_from_env();
+
+        // 3) Evaluate guard
+        let now = chrono::Utc::now();
+        let decision = evaluate_guard(mint, requested_size_usd, &tm, &th, now);
+
+        // 4) Log decision in structured way
+        tracing::info!(target="decision",
+            mint=%mint,
+            allowed=%decision.allowed,
+            reason=%decision.reason,
+            requested_size_usd=%decision.requested_size_usd,
+            vol_5m_usd=%decision.vol_5m_usd,
+            vol_15m_usd=%decision.vol_15m_usd,
+            liq_usd=?decision.liq_usd,
+            marketcap_usd=?decision.marketcap_usd,
+            amihud_5m=?decision.amihud_5m,
+            range_eff_5m=?decision.range_eff_5m,
+            "pre-trade guard decision"
+        );
+
+        if !decision.allowed {
+            tracing::warn!(%mint, reason=%decision.reason, "trade_blocked");
+            return Ok(());
+        }
+
+        // 5) continue with existing swap path build + simulate / send
+        self.executor.execute_swap(mint, requested_size_usd).await?;
+
+        Ok(())
     }
 }
